<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Test</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;/* 溢出隐藏 */
        }
    </style>

</head>
<body>
<span style="font-size:14px;"><meta http-equiv="X-UA-Compatible" content="IE=Chrome" /></span>
<!--<script src="../js/three/build/three.js"></script>-->
<!--<script src="../js/three/examples/js/controls/OrbitControls.js"></script>-->
<!--<script src="../js/three/examples/js/libs/dat.gui.min.js"></script>-->
<!--<script src="../js/three/examples/js/libs/stats.min.js"></script>-->
<!--<script src="../js/three/examples/js/libs/inflate.min.js"></script>-->
<!--<script src="../js/three/examples/js/math/SimplexNoise.js"></script>-->
<!--<script src="../js/three/examples/js/loaders/OBJLoader.js"></script>-->
<!--<script src="../js/three/examples/js/loaders/MTLLoader.js"></script>-->

<script src="../three/three.js"></script>
<script src="../three/js/controls/OrbitControls.js"></script>
<script src="../three/js/libs/dat.gui.min.js"></script>
<script src="../three/js/libs/stats.min.js"></script>
<script src="../three/js/libs/inflate.min.js"></script>
<script src="../three/js/math/SimplexNoise.js"></script>
<script src="../three/js/loaders/OBJLoader.js"></script>
<script src="../three/js/loaders/MTLLoader.js"></script>
<script src="../three/js/loaders/FBXLoader.js"></script>

<script src="../three/TweenMax.min.js"></script>

<script id="vs" type="x-shader/x-vertex">

      varying vec2 vUv;

      void main() {

      	vUv = uv;
      	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>

<script id="fs" type="x-shader/x-fragment">

      uniform sampler2D map;

      uniform vec3 fogColor;
      uniform float fogNear;
      uniform float fogFar;

      varying vec2 vUv;

      void main() {

      	float depth = gl_FragCoord.z / gl_FragCoord.w;
      	float fogFactor = smoothstep( fogNear, fogFar, depth );

      	gl_FragColor = texture2D( map, vUv );
      	gl_FragColor.w *= pow( gl_FragCoord.z, 20.0 );
      	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

      }
    </script>
<script type="x-shader/x-vertex" id="vs2">
    uniform mat4 normalMat;
    varying vec3 normalInterp;
    varying vec3 vertPos;
    varying float fog;
    //uniform vec3 lightPos;
    //varying vec3 lp;

    void main(){
      vec4 vertPos4 = modelViewMatrix * vec4(position, 1.0);

      vertPos = vec3(vertPos4) / vertPos4.w;
      normalInterp = vec3(normalMat * vec4(normal, 0.0));

      float d = sqrt(pow(vertPos.x,2.0)+pow(vertPos.y,2.0)+pow(vertPos.z,2.0));
      if(d>25.0){
          fog=0.0;
      }
      else if(d>18.0){
          fog = (25.0-d)/7.0;
      }
      else{
          fog=1.0;
      }

      gl_Position = projectionMatrix * vertPos4;
      //gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

</script>

<script type="x-shader/x-fragment" id="fs2">
    precision mediump float;
    varying vec3 normalInterp;  // Surface normal
    varying vec3 vertPos;       // Vertex position
    varying float fog;
    uniform int mode;   // Rendering mode
    uniform float Ka;   // Ambient reflection coefficient
    uniform float Kd;   // Diffuse reflection coefficient
    uniform float Ks;   // Specular reflection coefficient
    uniform float shininessVal; // Shininess
    // Material color
    uniform vec3 ambientColor;
    uniform vec3 diffuseColor;
    uniform vec3 specularColor;
    uniform vec3 lightPos; // Light position
    //varying vec3 lp;

    void main() {
      vec3 N = normalize(normalInterp);
      vec3 L = normalize(lightPos - vertPos);

      float lambertian = max(dot(N, L), 0.0);
      float specular = 0.0;
      if(lambertian > 0.0) {
        vec3 R = reflect(-L, N);      // Reflected light vector
        vec3 V = normalize(-vertPos); // Vector to viewer

        float specAngle = max(dot(R, V), 0.0);
        specular = pow(specAngle, shininessVal);
      }
      gl_FragColor = vec4(Ka * ambientColor*fog + Kd * lambertian * diffuseColor *fog + Ks * specular * specularColor *fog, 1.0);
      //gl_FragColor = vec4(Ka * ambientColor + Kd * lambertian * diffuseColor  + Ks * specular * specularColor , 1.0);
      if(mode == 2) gl_FragColor = vec4(Ka * ambientColor + Kd * lambertian * diffuseColor  + Ks * specular * specularColor , 1.0);

    }
</script>

<script type="module">
    // import { FBXLoader } from "../js/three/examples/jsm/loaders/FBXLoader.js";

    let scene, camera, renderer, directionalLight, ambient, controls, points, leavespoints, plane;
    let mesh, material;
    let sun;

    const clouds = [];
    const cloudb = [];
    let stats = initStats();
    let start_time = Date.now();
    let cloud_num = 100;
    let leaves = [];
    const objs = [];
    let cube;
    let collisionDetectCubeBox;
    let box31 = [];
    let box32 = [];
    let collision = false;
    let maze;
    let current = new THREE.Vector3;
    let simplex = new THREE.SimplexNoise();
    const clock = new THREE.Clock();
    let direction = [[0,1],[1,0],[0,0],[1,1]]//x:0,z:1,+:1,-:0
    let collision_detect = [-1,-1,-1];
    let collision_temp = [];
    /* 场景 */
    function initScene() {

        scene = new THREE.Scene();
        scene.background = new THREE.CubeTextureLoader()
            .setPath( '../models/Skybox/' )
            .load( [
                'px.jpg',
                'nx.jpg',
                'py.jpg',
                'ny.jpg',
                'pz.jpg',
                'nz.jpg'
            ] );
    }


    class Maze{
        constructor(){
            var cells=[];
            var walllist=[];
            var w1=[];
            var w2=[];
            for(var i =0;i<20;i++){
                w1[i] = [];
                cells[i] = [];
            }
            for(var i =0;i<21;i++){
                w2[i] = [];
            }
            for (var i =0;i<21;i++){
                for (var j =0;j<20;j++){
                    w2[i][j]=true;
                }
            }
            for (var i =0;i<20;i++){
                for (var j =0;j<21;j++){
                    w1[i][j]=true;
                }
            }
            for (var i =0;i<20;i++){
                for (var j =0;j<20;j++){
                    cells[i][j]=false;
                }
            }

            var visited=1;
            var r1=Math.floor(Math.random() * 20);
            var r2=Math.floor(Math.random() * 20);
            cells[r1][r2]=true;
            if(r1!=0){
                walllist.push([2,r1,r2]);//exclude 0
                if(r1!=19){
                    walllist.push([2,r1+1,r2]);//exclude 20
                }
            }
            if(r2!=0){
                walllist.push([1,r1,r2]);//exclude 0
                if(r2!=19){
                    walllist.push([1,r1,r2+1]);//exclude 20
                }
            }

            while(walllist.length!=0&&visited<=400){
                // console.log(walllist.length);
                var r3 = Math.floor(Math.random() * walllist.length);
                var randomwall = walllist[r3]; //[,i,j]
                var wi=randomwall[1];
                var wj=randomwall[2];
                if(randomwall[0]==1){         //no need to check if wall is boundary
                    if(cells[wi][wj]==false){
                        w1[wi][wj]=false;//passage
                        cells[wi][wj]=true;
                        visited++;
                        if((wi!=0)&& (walllist.includes([2,wi,wj])==false)&& (w2[wi][wj]==true)){
                            walllist.push([2,wi,wj]);//exclude 0
                            if((wi!=19) && (walllist.includes([2,wi+1,wj])==false)&& (w2[wi+1][wj]==true)){
                                walllist.push([2,wi+1,wj]);//exclude 20
                            }
                        }
                        if((wj!=0) && (walllist.includes([1,wi,wj])==false)&& (w1[wi][wj]==true)){
                            walllist.push([1,wi,wj]);//exclude 0
                            if((wj!=19) && (walllist.includes([1,wi,wj+1])==false)&& (w1[wi][wj+1]==true)){
                                walllist.push([1,wi,wj+1]);//exclude 20
                            }
                        }
                    }
                    else if(cells[wi][wj-1]==false){
                        w1[wi][wj]=false;//passage
                        cells[wi][wj-1]=true;
                        visited++;
                        if((wi!=0) && (walllist.includes([2,wi,wj-1])==false)&& (w2[wi][wj-1]==true)){
                            walllist.push([2,wi,wj-1]);//exclude 0
                            if((wi!=19) && (walllist.includes([2,wi+1,wj-1])==false)&&( w2[wi+1][wj-1]==true)){
                                walllist.push([2,wi+1,wj-1]);//exclude 20
                            }
                        }
                        if((wj-1!=0) && (walllist.includes([1,wi,wj-1])==false)&& (w1[wi][wj-1]==true)){
                            walllist.push([1,wi,wj-1]);//exclude 0
                            if((wj-1!=19) && (walllist.includes([1,wi,wj])==false)&& (w1[wi][wj]==true)){
                                walllist.push([1,wi,wj]);//exclude 20
                            }
                        }
                    }
                    walllist.splice(r3,1);
                }
                else if(randomwall[0]==2){
                    if(cells[wi][wj]==false){
                        w2[wi][wj]=false;//passage
                        cells[wi][wj]=true;
                        visited++;
                        if((wi!=0) &&(walllist.includes([2,wi,wj])==false)&& (w2[wi][wj]==true)){
                            walllist.push([2,wi,wj]);//exclude 0
                            if((wi!=19) && (walllist.includes([2,wi+1,wj])==false)&& (w2[wi][wj]==true)){
                                walllist.push([2,wi+1,wj]);//exclude 20
                            }
                        }
                        if((wj!=0) && (walllist.includes([1,wi,wj])==false)&& (w1[wi][wj]==true)){
                            walllist.push([1,wi,wj]);//exclude 0
                            if((wj!=19) && (walllist.includes([1,wi,wj+1])==false)&& (w1[wi][wj+1]==true)){
                                walllist.push([1,wi,wj+1]);//exclude 20
                            }
                        }
                    }
                    else if(cells[wi-1][wj]==false){
                        w2[wi][wj]=false;//passage
                        cells[wi-1][wj]=true;
                        visited++;
                        if((wi-1!=0) && (walllist.includes([2,wi-1,wj])==false)&& (w2[wi-1][wj]==true)){
                            walllist.push([2,wi-1,wj]);//exclude 0
                            if((wi-1!=19) && (walllist.includes([2,wi,wj])==false)&& (w2[wi][wj]==true)){
                                walllist.push([2,wi,wj]);//exclude 20
                            }
                        }
                        if((wj!=0) && (walllist.includes([1,wi-1,wj])==false) && (w1[wi-1][wj]==true)){
                            walllist.push([1,wi-1,wj]);//exclude 0
                            if((wj!=19) && (walllist.includes([1,wi-1,wj+1])==false) && (w1[wi-1][wj+1]==true)){
                                walllist.push([1,wi-1,wj+1]);//exclude 20
                            }
                        }
                    }
                    walllist.splice(r3,1);
                }
            }
            // console.log(w1);
            // console.log(w2);
            // console.log(cells);
            this.walls1=w1;
            this.walls2=w2;
            this.cells=cells;
            // for (var i =0;i<21;i++){
            //     for (var j =0;j<20;j++){
            //         w2[i][j]=false;
            //     }
            // }
            // for (var i =0;i<20;i++){
            //     for (var j =0;j<21;j++){
            //         w1[i][j]=false;
            //     }
            // }
        }
    }

    /* 相机 */
    function initCamera() {

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set( 100, 800, 300);

        camera.lookAt(current);

    }

    /* 渲染器 */
    function initRender() {

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);


    }

    /* 灯光 */
    function initLight() {

        // sun = new THREE.Mesh( new THREE.SphereBufferGeometry( 100, 12, 12 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
        //
        // scene.add( sun );
        //
        // lightpoint = new THREE.PointLight(0xffffff);
        // lightpoint.castShadow = true;
        // //lightpoint.position.set(300, 150, 200); //点光源位置
        // lightpoint.intensity = 5;
        // sun.add(lightpoint)


        //环境光
        let ambient = new THREE.AmbientLight(0xcccccc,0.5);
        scene.add(ambient);

        const directionalLight = new THREE.DirectionalLight( 0xffffff, 1);
        directionalLight.position.set(  0, 100, 0 ).normalize();
            //.normalize();
        directionalLight.castShadow = true;
        directionalLight.shadowCameraVisible=true;

        directionalLight.shadow.mapSize.width = 2048; // default
        directionalLight.shadow.mapSize.height = 2048; // default

        directionalLight.shadow.camera.near = 0.5; // default
        directionalLight.shadow.camera.far = 2000; // default
        directionalLight.shadow.camera.left = -1000; // default
        directionalLight.shadow.camera.right = 1000; // default
        directionalLight.shadow.camera.top = -1000; // default
        directionalLight.shadow.camera.bottom = 1000; // default


        sun = new THREE.Mesh( new THREE.SphereBufferGeometry( 100, 12, 12 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
        sun.add( directionalLight );
        scene.add( sun );



    }

    function initPlane() {
        //plane
        let planeGeometry = new THREE.PlaneBufferGeometry(2000, 2000);
        let planeMaterial = new THREE.MeshLambertMaterial({color: 0xb9d3ff});

        plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.y = -0;

        //告诉底部平面需要接收阴影
        // plane.receiveShadow = true;

        scene.add(plane);
    }

    function initGirl() {
        let cubeGeometry = new THREE.CubeGeometry(10,10,10);

        let cubeMaterial = new THREE.MeshLambertMaterial({color: 0x00ffff});

        cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.x = 25;
        cube.position.y = 0;
        cube.position.z = 25;

        //告诉立方体需要投射阴影
        // cube.receiveShadow = false;
        cube.castShadow = true;
        cube.scale.set(0.5,0.5,0.5);

        collisionDetectCubeBox = new THREE.Box3().setFromObject(cube);

        scene.add(cube);
        //
        // let cube_test = cube.clone();
        // cube_test.position.set(500,60,500);
        // cube_test.scale.set(30,30,30);
        // scene.add(cube_test);

        let loader = new THREE.FBXLoader();

        loader.load("../models/Catwalk Walking.fbx", function (object) {
            console.log(object);

            const mixer = new THREE.AnimationMixer(object);
            mixer.clipAction(object.animations[0]).play();
            objs.push({object, mixer});
            object.children[0].castShadow = true;
            scene.add(object);
            object.scale.set(0.2,0.2,0.2);
            object.position.set(25,50,25);


        }, undefined, function ( error ) {

            console.error( error );

        });


    }
    /* 控制器 */
    function initControls() {

        controls = new THREE.OrbitControls(camera, renderer.domElement);

        /* 属性参数默认 */

    }

    function initSnow() {

        /* 雪花图片 */
        const texture = new THREE.TextureLoader().load('../models/snowflake2.png');

        let geometry= new THREE.Geometry();

        let pointsMaterial = new THREE.PointsMaterial({

            size:7,
            transparent:true,
            opacity:0.8,
            map:texture,
            blending:THREE.AdditiveBlending,
            sizeAttenuation:true,
            depthTest: false
        });

        let range = 100;

        for (let i = 0; i < 300; i++ ) {

            let vertice = new THREE.Vector3(
                Math.random() * range - range / 2,
                Math.random() * range * 5 + 50,
                Math.random() * range - range / 2);
            /* 纵向移动速度 */
            vertice.velocityY = 0.1 + Math.random() / 3;
            /* 横向移动速度 */
            vertice.velocityX = (Math.random() - 0.5) / 3;

            /* 将顶点加入几何 */
            geometry.vertices.push(vertice);

        }

        geometry.center();

        points = new THREE.Points(geometry, pointsMaterial);
        points.position.set(25,50,25);

        scene.add(points);

    }

    function initLeaves() {

        function isArray(object) {
            return Object.prototype.toString.call(object) === '[object Array]';
        }

        function isNumber(object) {
            return typeof object == 'number';
        }

        function random(min, max) {
            if (isArray(min)) return min[~~(M.random() * min.length)];
            if (!isNumber(max)) max = min || 1, min = 0;
            return min + Math.random() * (max - min);
        }


        let Leaf = function(index, params) {
            console.log(params)
            Leaf.TYPE_GREEN_1 = 1;
            Leaf.TYPE_DRY_1 = 3;

            this.index = index;
            this.params = params;

            this.value = 0;
            this.angle = new THREE.Vector3(0, random(), random());
            this.radius = new THREE.Vector3(random(10), random(), random(10));
            this.pos = new THREE.Vector3(params.boundingBox.x, params.boundingBox.y * 0.5 + random(params.boundingBox.y * 0.05), params.boundingBox.z);
            this.mass = random(0.8, 1.0);
            this.scale = random(0.8, 3);

            if (random() > 0.5) this.type = Leaf.TYPE_DRY_1;
            else this.type = Leaf.TYPE_GREEN_1;



            this.initMesh();
        }
        Leaf.prototype.initMesh = function () {
            const geometry = new THREE.BufferGeometry();
            // positions
            const positions = new THREE.BufferAttribute(new Float32Array(4 * 3), 3);
            const bend = (this.type === Leaf.TYPE_GREEN_1) ? 0.25 : 0.1;
            positions.setXYZ(0, -0.5, 0.5, bend);
            positions.setXYZ(1, 0.5, 0.5, 0.0);
            positions.setXYZ(2, -0.5, -0.5, 0.0);
            positions.setXYZ(3, 0.5, -0.5, bend);
            geometry.setAttribute('position', positions);

            // uvs
            let uvs = null;
            if (this.params.uv) {
                uvs = new THREE.BufferAttribute(this.params.uv, 2);
            } else {
                uvs = new THREE.BufferAttribute(new Float32Array(4 * 2), 2);
                uvs.setXYZ(0, 0.0, 0.0);
                uvs.setXYZ(1, 1.0, 0.0);
                uvs.setXYZ(2, 0.0, 1.0);
                uvs.setXYZ(3, 1.0, 1.0);
            }
            geometry.setAttribute('uv', uvs);

            // index
            geometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));

            // image
            const image = document.createElement('img');
            image.crossOrigin = "anonymous";
            const texture = new THREE.Texture(image);
            image.onload = function() {
                texture.needsUpdate = true;
            };

            if (this.type === Leaf.TYPE_GREEN_1) image.src = "../models/leaf.png";
            else if (this.type === Leaf.TYPE_DRY_1) image.src =  "../models/yellowleaf.png";

            const material = new THREE.MeshBasicMaterial();
            material.color = new THREE.Color().setHSL(random(0.2, 0.4), 0.4, 0.5);
            // if (this.params.map) material.map = this.params.map;
            material.map = texture;
            material.side = THREE.DoubleSide;
            material.transparent = true;
            material.depthTest = false;

            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.visible = false;
            this.mesh.scale.set(this.scale, this.scale, this.scale);

            // let mesh = new THREE.Mesh(geometry, material);
            // //this.mesh.visible = false;
            // let scale = random(6, 10);
            // mesh.scale.set(scale, scale, scale);
        }

        Leaf.prototype.fall = function() {//
            this.pos = new THREE.Vector3(params.boundingBox.x, params.boundingBox.y * 0.5 + random(params.boundingBox.y * 0.05), params.boundingBox.z);
            this.mesh.visible = true;
            this.isFalling = true;
        }

        Leaf.prototype.hide = function() {
            this.mesh.visible = false;
            this.isFalling = false;
            TweenMax.killTweensOf(this);
        }

        Leaf.prototype.rest = function() {
            this.isFalling = false;
            TweenMax.killTweensOf(this);
            this.mesh.rotation.x = this.mesh.rotation.x % Math.PI;
            TweenMax.to(this.mesh.rotation, 0.3, {
                x: Math.PI / 2,
                y: 0
            });
        }

        Leaf.prototype.update = function(wind = 0, gravity = 1) {
            if (!this.isFalling) return;

            const noise = simplex.noise(Date.now() * 0.0002, this.index, 0);
            this.value = noise * 2;

            this.angle.x += 0.01 / Math.max(noise, 0.05);
            // this.angle.y += noise;
            this.angle.z += noise * 0.05;

            this.pos.x += wind;
            // this.pos.y += (1 - this.value) * this.radius.y * this.gravity * -0.1 - this.mass;
            // this.pos.y += (2 - abs(this.value)) * gravity * -this.mass;
            this.pos.y -= gravity - this.value;

            this.mesh.position.x = this.value * this.radius.x;
            this.mesh.position.y = Math.cos(this.value * Math.PI / 2) * -this.radius.y;
            this.mesh.position.z = Math.sin(this.angle.z) * this.radius.z;

            this.mesh.position.x += this.pos.x;
            this.mesh.position.y += this.pos.y;
            this.mesh.position.z += this.pos.z;

            this.mesh.rotation.x = this.angle.x;
            // this.mesh.rotation.x = HALF_PI + sin(this.value * HALF_PI);
            // this.mesh.rotation.y = PI + this.angle.y;
            this.mesh.rotation.z = this.angle.z;
        }
        // listeners
        simplex = new THREE.SimplexNoise();

        let container = new THREE.Object3D();

        scene.add(container);

        // defaults
        // let params = {};
        // params.amount = 30;
        // this.params.interval = 0.1;
        // this.params.boundingBox = new THREE.Vector3(150, 300, 100);
        // this.gravity = this.params.gravity = 2;
        // this.wind = this.params.wind = 0.5;

        // leaves




        for (let i = 0; i < params.amount; i++) {
            let leaf = new Leaf(i, params);
            leaves.push(leaf);
            container.add(leaf.mesh);
        }


        // this.allowRest = false;
        // this.range = [0, 5];

        for (let i = 0; i < leaves.length; i++) {
            const leaf = leaves[i];
            TweenMax.delayedCall(i * params.interval, leaf.fall.bind(leaf));
        }
    }
    let params = {
        amount: 10,
        interval: 0.1,
        boundingBox: new THREE.Vector3(150, 300, 100),
        gravity: 1.5,
        wind: 0.5,
    };
    function leavesAnimation () {

        const noise = simplex.noise(Date.now() * 0.00001, 1, 0);
        const wind = Math.abs(noise) * 0.5 * 0.5;

        for (let i = 0; i < leaves.length; i++) {
            const leaf = leaves[i];
            leaf.update(wind, params.gravity);

            // when leaf touches the ground
            if (leaf.mesh.position.y < 50) {
                // if (this.allowRest) leaf.rest();
                // else leaf.fall();
                leaf.rest();
                // leaf.hide();
                // leaf.fall();
            }
        }


    }

    function initCloud(size, clouds, height) {
        const texture = new THREE.TextureLoader().load(
            "../models/cloud.png",

        );
        texture.magFilter = THREE.LinearMipMapLinearFilter;
        texture.minFilter = THREE.LinearMipMapLinearFilter;

        let fog = new THREE.Fog(0x4584b4, -100, 3000);
        let geometry = new THREE.Geometry();

        material = new THREE.ShaderMaterial({
            uniforms: {
                map: { type: "t", value: texture },
                fogColor: { type: "c", value: fog.color },
                fogNear: { type: "f", value: fog.near },
                fogFar: { type: "f", value: fog.far }
            },
            vertexShader: document.getElementById("vs").textContent,
            fragmentShader: document.getElementById("fs").textContent,
            depthWrite: false,
            depthTest: false,
            transparent: true,
            side:THREE.DoubleSide
        });

        let plane = new THREE.Mesh(new THREE.PlaneGeometry(size,size), new THREE.MeshBasicMaterial({
           side: THREE.DoubleSide
        }));
        plane.receiveShadow = true;
        plane.rotation.x = -Math.PI / 2;
        for (let i = 0; i < cloud_num; i++) {
            plane.position.x = Math.random() * 2000 - 1000;
            plane.position.y = Math.random() * Math.random() * 200 + height;
            plane.position.z = Math.random() * 2000 - 1000;
            plane.rotation.z = Math.random() * Math.PI;
            plane.scale.x = plane.scale.y =
                (Math.random() * Math.random() )* 1.5 + 1;
            geometry.mergeMesh(plane);

        }

        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);
        //mesh.castShadow = true;
        clouds.push( mesh );

    }

    function initGround(){

        var exit = Math.floor(Math.random() * 80);
        var exitwall;
        if(exit<=19){
            exitwall = 0;
        }
        else if(exit<=39){
            exitwall = 1;
            exit-=20;
        }
        else if(exit<=59){
            exitwall = 2;
            exit-=40;
        }
        else{
            exitwall=3;
            exit-=60;
        }
        // console.log(exitwall);
        // console.log(exit);

        // uniforms
        var uniformList= [];
        var exiti,exitj;
        for(var i=0;i<3;i++){
            uniformList[i] = [];
        }
        for(var i=0;i<20;i++){
            uniformList[0][i]=[];
            uniformList[1][i]=[];
        }
        for(var i=0;i<21;i++){
            uniformList[2][i]=[];
        }
        //grounds
        for(var i=0;i<20;i++){
            for(var j=0;j<20;j++){
                uniformList[0][i][j]={
                    // projection:{value:new THREE.Matrix4()},
                    // modelview:{value:new THREE.Matrix4()},
                    normalMat:{value: new THREE.Matrix4()},
                    mode:{value:2},
                    lightPos: { value: new THREE.Vector3(0,0,5)},
                    Ka:{value: 0.3},
                    Kd:{value: 0.9},
                    Ks:{value: 0.5},
                    ambientColor: {value: new THREE.Color( 0x445511 )},
                    diffuseColor: {value: new THREE.Color( 0x445511 )},
                    specularColor: {value: new THREE.Color( 0x445511 )},
                    shininessVal:{value:2},
                };
            }
        }
        //walls1
        for(var i=0;i<20;i++){
            for(var j=0;j<21;j++){
                var u ={
                    normalMat:{value: new THREE.Matrix4()},
                    mode:{value:1},
                    lightPos: { value: new THREE.Vector3(0,0,5)},
                    Ka:{value: 0.3},
                    Kd:{value: 0.9},
                    Ks:{value: 0.5},
                    ambientColor: {value: new THREE.Color( 0xbbbbbb )},
                    diffuseColor: {value: new THREE.Color( 0xbbbbbb )},
                    specularColor: {value: new THREE.Color( 0xbbbbbb )},
                    shininessVal:{value:20},
                };
                uniformList[1][i][j] = u;
            }
        }
        //walls2
        for(var i=0;i<21;i++){
            for(var j=0;j<20;j++){
                var u ={

                    normalMat:{value: new THREE.Matrix4()},
                    mode:{value:1},
                    lightPos: { value: new THREE.Vector3(0,0,5)},
                    Ka:{value: 0.3},
                    Kd:{value: 0.9},
                    Ks:{value: 0.5},
                    ambientColor: {value: new THREE.Color( 0xbbbbbb )},
                    diffuseColor: {value: new THREE.Color( 0xbbbbbb )},
                    specularColor: {value: new THREE.Color( 0xbbbbbb )},
                    shininessVal:{value:15},
                };
                uniformList[2][i][j] = u;
            }
        }


        var uniforms_exit = {
            // projection:{value:new THREE.Matrix4()},
            // modelview:{value:new THREE.Matrix4()},
            normalMat:{value: new THREE.Matrix4()},
            mode:{value:1},
            lightPos: { value: new THREE.Vector3(0,0,5)},
            Ka:{value: 0.3},
            Kd:{value: 1.0},
            Ks:{value: 0.2},
            ambientColor: {value: new THREE.Color( 0xffffff )},
            diffuseColor: {value: new THREE.Color( 0xbbbbbb )},
            specularColor: {value: new THREE.Color( 0x00bbbb )},
            shininessVal:{value:10},
        };



        // 3. ground
        var textureLoader = new THREE.TextureLoader();
        var tree_color = textureLoader.load('../models/grass/grass_image.jpg');
        tree_color.repeat.set(1, 1);
        tree_color.wrapS = tree_color.wrapT = THREE.RepeatWrapping;
        tree_color.anisotropy = 16;
        tree_color.needsUpdate = true;
        var shininess = 30, specular = 0x333333, bumpScale = 1, shading = THREE.SmoothShading;
        var materials_grass = [];
        materials_grass.push( new THREE.MeshPhongMaterial( {  map: tree_color, bumpScale: bumpScale, transparent: false, specular: specular, shininess: shininess, flatShading: shading } ) );

        var grounds=[];
        for(var i =0;i<20;i++){
            grounds[i] = [];
        }
        for(var i=0;i<20;i++){
            for(var j=0;j<20;j++){
                var geometry = new THREE.BoxGeometry( 45, 5, 45 );

                var material =  materials_grass[0];
                grounds[i][j] = new THREE.Mesh( geometry, material );
                grounds[i][j].position.x=i*45+25-500;
                grounds[i][j].position.z=j*45+25-500;
                grounds[i][j].position.y=50;
                // grounds[i][j].castShadow = true;
                grounds[i][j].receiveShadow = true;
                uniformList[0][i][j].normalMat.value.getInverse(grounds[i][j].modelViewMatrix);
                uniformList[0][i][j].normalMat.value=uniformList[0][i][j].normalMat.value.transpose();
                scene.add(grounds[i][j]);
            }
        }

        // 4. walls
        var walls1=[];
        var walls2=[];

        maze = new Maze();
        for(var i =0;i<20;i++){
            walls1[i] = [];
            box31[i] = [];
        }

        for(var i=0;i<20;i++){
            for(var j=0;j<21;j++){
                geometry = new THREE.BoxGeometry( 50, 30, 5 );//horizontal walls
                //material = new THREE.MeshBasicMaterial( { color: 0x222222 } );
                // uniforms_walls.normalMat=camera.normalMatrix;
                //uniforms_walls.normalMat=camera.normalMatrix;
                material =  new THREE.ShaderMaterial( {
                    //uniforms: uniforms_walls,
                    uniforms: uniformList[1][i][j],
                    vertexShader: document.getElementById("vs2").textContent,
                    fragmentShader: document.getElementById("fs2").textContent,
                } );
                if(exitwall==0 && j == 0 && i ==exit){
                    material =  new THREE.ShaderMaterial( {
                        uniforms: uniforms_exit,
                        vertexShader: document.getElementById("vs2").textContent,
                        fragmentShader: document.getElementById("fs2").textContent,
                    } );
                    exiti=i;
                    exitj=j;
                }
                if(exitwall==1 && j == 20 && i ==exit){
                    material =  new THREE.ShaderMaterial( {
                        uniforms: uniforms_exit,
                        vertexShader: document.getElementById("vs2").textContent,
                        fragmentShader: document.getElementById("fs2").textContent,
                    } );
                    exiti=i;
                    exitj=j;
                }
                walls1[i][j] = new THREE.Mesh( geometry, material );
                walls1[i][j].position.x=i*45+25-500;
                walls1[i][j].position.z=j*45+2.5-500;
                walls1[i][j].position.y=0;

                walls1[i][j].material.uniforms.normalMat.value.getInverse(walls1[i][j].modelViewMatrix);
                walls1[i][j].material.uniforms.normalMat.value=walls1[i][j].material.uniforms.normalMat.value.transpose();
                // uniforms_walls.normalMat.value.getInverse(walls1[i][j].modelViewMatrix);
                // uniforms_walls.normalMat.value=uniforms_walls.normalMat.value.transpose();

                // walls1[i][j].castShadow=true;
                // walls1[i][j].receiveShadow=true;
                box31[i][j] = new THREE.Box3().setFromObject(walls1[i][j]);
                if (maze.walls1[i][j]==true){
                    scene.add(walls1[i][j]);
                }
            }
        }
        for(var i =0;i<21;i++){
            walls2[i] = [];
            box32[i] = [];
        }
        for(var i=0;i<21;i++){
            for(var j=0;j<20;j++){
                geometry = new THREE.BoxGeometry( 5, 30, 50 );
                //material = new THREE.MeshBasicMaterial( { color: 0x222222 } );
                //material = new THREE.MeshPhongMaterial();
                material =  new THREE.ShaderMaterial( {
                    //uniforms: uniforms_walls,
                    uniforms: uniformList[2][i][j],
                    vertexShader: document.getElementById("vs2").textContent,
                    fragmentShader: document.getElementById("fs2").textContent,
                } );
                if(exitwall==2 && i == 0 && j ==exit){
                    material =  new THREE.ShaderMaterial( {
                        uniforms: uniforms_exit,
                        vertexShader: document.getElementById("vs2").textContent,
                        fragmentShader: document.getElementById("fs2").textContent,
                    } );
                    exiti=i;
                    exitj=j;
                }
                if(exitwall==3 && i == 20 && j ==exit){
                    material =  new THREE.ShaderMaterial( {
                        uniforms: uniforms_exit,
                        vertexShader: document.getElementById("vs2").textContent,
                        fragmentShader: document.getElementById("fs2").textContent,
                    } );
                    exiti=i;
                    exitj=j;
                }
                walls2[i][j] = new THREE.Mesh( geometry, material );
                walls2[i][j].position.x=i*45+2.5-500;
                walls2[i][j].position.z=j*45+25-500;
                walls2[i][j].position.y=0;

                walls2[i][j].material.uniforms.normalMat.value.getInverse(walls2[i][j].modelViewMatrix);
                walls2[i][j].material.uniforms.normalMat.value=walls2[i][j].material.uniforms.normalMat.value.transpose();

                box32[i][j] = new THREE.Box3().setFromObject(walls2[i][j]);

                if (maze.walls2[i][j]==true){
                    scene.add(walls2[i][j]);
                }
            }
        }


        var OBJLoader = new THREE.OBJLoader();//obj加载器
        var MTLLoader = new THREE.MTLLoader();//材质文件加载器
        var textureLoader = new THREE.TextureLoader();
        var tree_color = textureLoader.load('../models/tree_2/treePine.jpg');
        var tree_alpha = textureLoader.load('../models/tree_2/treePineOpacity.jpg');
        tree_color.repeat.set(1, 1);
        tree_color.wrapS = tree_color.wrapT = THREE.RepeatWrapping;
        tree_color.anisotropy = 16;
        tree_color.needsUpdate = true;
        var shininess = 30, specular = 0x333333, bumpScale = 1, shading = THREE.SmoothShading;
        var materials_out = [];
        materials_out.push( new THREE.MeshPhongMaterial( { map: tree_color, alphaMap: tree_alpha, bumpScale: bumpScale, transparent: true, specular: specular, shininess: shininess, flatShading: shading } ) );



        OBJLoader.load('../models/tree_2/file.obj', function(obj) {
            obj.children[0].material = materials_out[0];
            console.log(obj);
            // obj.rotation.set(1.57,0,0);
            obj.scale.set(0.125,0.25,0.125);
            obj.position.y = 50;
            for (var i = 1; i < 20; i++) {
                for (var j = 1; j < 20; j++) {
                    if (maze.walls1[i][j] == true && Math.random() < 1) {
                        var tree_model = obj.clone();
                        tree_model.children[0].castShadow=true;
                        tree_model.position.x = walls1[i][j].position.x;
                        tree_model.position.z = walls1[i][j].position.z;
                        scene.add(tree_model);
                    }
                }
            }
            for (var i = 1; i < 20; i++) {
                for (var j = 1; j < 20; j++) {
                    if (maze.walls2[i][j] == true && Math.random() < 1) {
                        var tree_model = obj.clone();
                        tree_model.children[0].castShadow=true;
                        tree_model.position.x = walls2[i][j].position.x;
                        tree_model.position.z = walls2[i][j].position.z;
                        scene.add(tree_model);
                    }
                }
            }
        })

        let loader = new THREE.FBXLoader();

        loader.load("../models/75-flowergrass/FBX/flower01.fbx", function (object) {
            console.log(object);
            // scene.add(object);
            object.scale.set(0.5,0.25,0.5);
            object.position.set(0,50,0);
            for (var i = 2; i < 20; i++) {
                for (var j = 2; j < 20; j++) {
                    if (Math.random() < 0.15){
                        var flower_model = object.clone();
                        flower_model.position.x = walls1[i][j].position.x + Math.random() * 50 * Math.random() * (-1);
                        flower_model.position.z = walls1[i][j].position.z + Math.random() * 50 * Math.random() * (-1);
                        scene.add(flower_model);
                    }
                }
            }
        }, undefined, function ( error ) {
            console.error( error );
        });

        loader.load("../models/75-flowergrass/FBX/flower02.fbx", function (object) {
            console.log(object);
            // scene.add(object);
            object.scale.set(0.5,0.25,0.5);
            object.position.set(0,50,0);
            for (var i = 2; i < 20; i++) {
                for (var j = 2; j < 20; j++) {
                    if (Math.random() < 0.15){
                        var flower_model = object.clone();
                        flower_model.position.x = walls2[i][j].position.x + Math.random() * 50 * Math.random() * (-1);
                        flower_model.position.z = walls2[i][j].position.z + Math.random() * 50 * Math.random() * (-1);
                        scene.add(flower_model);
                    }
                }
            }
        }, undefined, function ( error ) {
            console.error( error );
        });

        loader.load("../models/75-flowergrass/FBX/flower03.fbx", function (object) {
            console.log(object);
            // scene.add(object);
            object.scale.set(0.5,0.25,0.5);
            object.position.set(0,50,0);
            for (var i = 2; i < 20; i++) {
                for (var j = 2; j < 20; j++) {
                    if (Math.random() < 0.15){
                        var flower_model = object.clone();
                        flower_model.position.x = walls1[i][j].position.x + Math.random() * 50 * Math.random() * (-1);
                        flower_model.position.z = walls1[i][j].position.z + Math.random() * 50 * Math.random() * (-1);
                        scene.add(flower_model);
                    }
                }
            }
        }, undefined, function ( error ) {
            console.error( error );
        });



    }

    /* 性能插件 */
    function initStats() {

        let stats = new Stats();

        document.body.appendChild(stats.domElement);

        return stats;

    }


    /* 窗口变动触发 */
    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

    }
    function cloudAnimation (clouds, speed) {
        const timer = 0.0001 * Date.now();
        for ( let i = 0, il = clouds.length; i < il; i ++ ) {

            const cloud = clouds[ i ];

            cloud.position.x =  speed * Math.cos( timer + i );
            cloud.position.z =  speed * Math.sin( timer + i * 1.1 );

        }
    }

    function sunAnimation (speed) {
        const timer = Date.now() * 0.00025;
        // var timer = 1;

        // move light in circle around center
        // change light height with sine curve

        sun.position.x = Math.sin( timer * speed ) * 1000;
        sun.position.y = Math.cos( timer * speed ) * 1500;
        sun.position.z = Math.cos( timer * speed ) * 1000;
        // sun.visible = sun.position.y >= -100;
        sun.intensity = Math.cos( timer * speed );
    }

    function girlMoving () {
        let index = 3;
        //let current = direction[i];
        function choosedirction(current, speed) {
            if(current[0] === 0 && current[1] === 0){
                objs.forEach(({object}) => {
                    object.position.x -= speed;
                });
            }
            else if(current[0] === 0 && current[1] === 1){
                objs.forEach(({object}) => {
                    object.position.x += speed;
                });
            }
            else if(current[0] === 1 && current[1] === 0){
                objs.forEach(({object}) => {
                    object.position.z -= speed;
                });
            }
            else if(current[0] === 1 && current[1] === 1){
                objs.forEach(({object}) => {
                    object.position.z += speed;
                });
            }
        }

        function choosedirction_box(current, speed) {
            if(current[0] === 0 && current[1] === 0){
                cube.position.x -= speed;
            }
            else if(current[0] === 0 && current[1] === 1){
                cube.position.x += speed;
            }
            else if(current[0] === 1 && current[1] === 0){
                cube.position.z -= speed;
            }
            else if(current[0] === 1 && current[1] === 1){
                cube.position.z += speed;
            }
        }

        document.addEventListener('keydown', keydown);
        function keydown(e){

            switch(e.keyCode) {
                case 87://w
                    // console.log(objs);
                    choosedirction_box(direction[index], 2.7);
                    collisionDetectCubeBox.setFromObject(cube);
                    for(var i=0;i<20;i++){
                        for(var j =0;j<21;j++){
                            if(collisionDetectCubeBox.intersectsBox(box31[i][j]) && maze.walls1[i][j]===true){
                                collision=true;
                                collision_temp = [0,i,j];
                                break;
                            }
                        }
                    }
                    for(var i=0;i<21;i++){
                        for(var j =0;j<20;j++){
                            if(collisionDetectCubeBox.intersectsBox(box32[i][j]) && maze.walls2[i][j]===true){
                                collision=true;
                                collision_temp = [1,i,j];
                                break;
                            }
                        }
                    }
                    if (collision == false){
                        choosedirction(direction[index], 2.7);
                    }
                    objs.forEach(({object}) => {
                        cube.position.set(object.position.x,object.position.y-50,object.position.z);
                        points.position.set(object.position.x,object.position.y,object.position.z);
                    });

                    if (collision === true){
                        for (var i=0;i<3;i++){
                            if (collision_temp[i]!=collision_detect[i]){
                                console.log(cube.position.x);
                                params.boundingBox = new THREE.Vector3(cube.position.x, 250,cube.position.z);
                                initLeaves();
                                leavesAnimation ();
                                collision_detect = collision_temp;
                                break;
                            }
                        }
                    }

                    renderer.render(scene, camera);
                    collision = false;
                    break;

            }
        }
        document.addEventListener('keyup',keyup);
        function keyup(e){
            switch(e.keyCode) {
                case 65://a
                    index = (index+1)%4;
                    objs.forEach(({object}) => {
                        object.rotation.y += Math.PI/2;

                    });
                    break;
                case 83://s
                    index = (index+2)%4;
                    objs.forEach(({object}) => {
                        object.rotation.y += Math.PI;
                        // object.position.z -= 2.5;
                    });
                    break;
                case 68://d
                    index = (index+3)%4 ;
                    objs.forEach(({object}) => {
                        object.rotation.y -= Math.PI/2;

                    });
                    renderer.render(scene, camera);
                    break;
            }
        }
    }

    /* 数据更新 */
    function update() {

        stats.update();
        cloudAnimation (clouds,200);
        cloudAnimation (cloudb,100);
        leavesAnimation ();
        sunAnimation (1);


        let vertices = points.geometry.vertices;
        vertices.forEach(function (v) {

            v.y = v.y - (v.velocityY);
            v.x = v.x - (v.velocityX);

            if (v.y <= 0) v.y = 60;
            if (v.x <= -20 || v.x >= 20) v.velocityX = v.velocityX * -1;

        });
        /* 顶点变动之后需要更新，否则无法实现雨滴特效 */
        points.geometry.verticesNeedUpdate = true;




    }


    /* 初始化 */
    function init() {

        initScene();
        initCamera();
        initRender();
        initLight();
        initPlane();
        initControls();
        initGirl();
        initSnow();
        initCloud(100, clouds, 550);
        initCloud(150, cloudb, 500);
        // initLeaves();
        girlMoving ();
        initGround();

        /* 监听事件 */
        window.addEventListener('resize', onWindowResize, false);

    }

    /* 循环渲染 */
    function animate() {

        objs.forEach(({mixer}) => {mixer.update(clock.getDelta());});

        //record the charactor position
        objs.forEach(({object}) => {
            current[0] = object.position.x;
            current[1] = object.position.y;
            current[2] = object.position.z;
        });

        // console.log(current)
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        update();

    }

    /* 初始加载 */
    (function () {
        console.log("three init start...");

        init();
        animate();

        console.log("three init send...");
    })();






</script>
</body>
</html>